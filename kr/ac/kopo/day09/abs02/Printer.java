package kr.ac.kopo.day09.abs02;

/*
 * 항상 메소드의 우선순위는 내안에 있는 메소드가 가장 우선순위를 갖고 실행된다. 즉, 만약 상속관계가 존재하는 클래스에서 오버라이딩된 메소드가
 * 존재할 때, 오버라이딩된 메소드는 나의 클래스안에 존재하므로 가장 우선순위를 갖고 실행된다. 동일한 이름을 가진 메소드가 부모클래스에 존재함에도.
 * 
 * 오버라이딩된 메소드가 존재할때, 부모클래스에 존재하는 동일한 이름의 메소드는 사용될 일이 없다. 즉, 부모클래스에 존재하는 메소드에는 비효율이 발생
 * 하는 것이다. 따라서, 어차피 부모클래스에 존재하는 메소드는 동작될일이 없으므로 비효율을 줄이기 위해서 부모클래스의 메소드를 추상메소드화 해야한다.
 * 
 * 추상클래스를 상속받은 자식클래스에는 자동으로 추상메소드가 상속되지만, 이것만으로는 오류가 발생한다. 반드시 추상클래스에 존재하는 추상메소드를
 * 오버라이딩 해야 오류가 발생하지 않는다. 즉, 구체적으로 자식클래스에서 추상메소드를 오버라이딩하여 정의해줘야한다. 즉, 반드시 부모클래스에 존재하는
 * 추상메소드가 반드시 오버라이딩 되어 자식클래스에 존재해야하기 때문에(존재하지 않으면 오류가 발생하므로) 부모클래스의 추상메소드를 반드시 자식클래스
 * 에서 의무적으로 규정해야하는 강제성이 여기서 성립되게 되는 것이다. 
 * 
 * 부모클래스에서 print() 메소드를 추상메소드로 정의하면, 반드시 모든 printer 클래스의 자식클래스에는 print() 메소드를 오버라이딩하여 재정의
 * 해야만 오류가 발생하지 않고 성립하므로, 모든 자식클래스에서 print() 메소드가 내용부가 정의된 채로 존재하게되므로, print() 메소드에 대한
 * 강제성이 자식클래스에서 이와같이 부여되는 것이다.
 * 
 * 기존의 일반적인 클래스에서는 그 클래스가 자식클래스에 상속될때, 부모클래스에 존재하는 메소드가 자식클래스에 오버라이딩되도 그만 안되도 그만 아무런
 * 상관이 없었지만, 추상클래스로 정의된 클래스에 존재하는 추상메소드는 반드시 자식클래스에 오버라이딩되어 재정의되어야만 오류가 발생하지 않는다.
 * 
 * 상속관계에서는 자식 클래스로 만들어진 인스턴스 객체에 대한 주소값을 갖고 있는 참조변수값의 참조자료형을 부모클래스로 정의해도 아무런 문제가 발생
 * 하지 않으므로 가능하다. 왜냐하면, 부모클래스에 존재하는 모든 메소드와 자식클래스에 존재하는 모든 메소드를 위와같은 상황에서도 사용할 수 있기 때문이다.
 * 
 * 추상클래스도 추상메소드를 갖고 있고, 인터페이스도 추상메소드를 갖고 있다.
 * 
 * 메소드의 접근 제한자를 private로 설정하면 나의 클래스 내부에서만 사용할 수 있는 메소드이다. 외부에다가 메소드를 드러내고 싶지 않을때 사용한다.
 * 
 * 도큐먼테이션에서는 어떤 클래스의 public 메소드만 보여준다.
 * 
 * private 메소드를 가진 부모클래스가 자식클래스에 상속되어도, 자식클래스에서 private 메소드는 보이지 조차도 않으므로 사용할 수없다. 오직
 * 상속된 경우 public의 경우이거나 protected 인 메소드만 보여져서 자식클래스에서 사용할 수 있다.
 * 
 * 메소드를 정의할때 내용부 {} 안에 또 같은 클래스 안의 메소드를 사용할 수 있다.
 * 
 * 멤버변수는 일반적으로 대부분 private로 설정한다.
 * 
 * 형변환을 기본자료형을 사용할 때 배운적이있다.
 * 
 * 대입 연산자를 기준으로 왼쪽과 오른쪽의 기준이 달랐을때, 형변환이 발생된다.
 * 참조자료형에서도 형변환이 발생할 수 있는데, 이러한 형변환을 객체형변환이라고 한다. 객체형변환에서도 묵시적형변환과 명시적형변환이 존재한다.
 * 
 * 묵시적 형변환은 형변환 키워드를 생략할 수 있는 경우를 의미하고 명시적 형변환은 형변환키워드를 생략할 수 없이 반드시 구체적으로 규정해줘야하는 경우를
 * 말한다.
 * 
 * 클래스와 클래스 사이에서는 어떤 클래스가 더 큰지를 생각할 수없다. 그러므로 객체의 형변환에서는 크기를 기준으로 형변환을 발생시키지 않는다.
 * 객체의 형변환은 무조건 대입연산자를 기준으로 좌변과 우변의 변수의 타입이 다른경우에 발생하게 된다. 그리고 클래스와 클래스의 크기개념으로 비교할 수
 * 없으므로, 오직 대입연산자를 기준으로 좌변과 우변의 클래스가 상속관계에 있을때만 객체의 형변환이 발생한다.
 * 이러한 객체의 형변환은 좌변과 우변의 클래스가 상속관계가 존재하지 않을때는 발생하지 않아서 오류가 발생한다. 오직 상속관계일 경우에만
 * 대입연산자에의해 객체의 형변환이 발생한다.
 * 
 * 묵시적형변환은 대입연산자를 기준으로 우변에 하위클래스의 타입이존재하고 좌변에 상위클래스의 타입이존재할때 하위 클래스의 타입이 부모클래스의 타입으로
 * 바뀌는 묵시적 형변환이 발생하게된다.
 * 
 * 자식의 인스턴스 객체를 자식의 클래스로 new를 통해 만드는 순간 super()생성자에 의해 부모클래스의 객체도 생성되는데,이때, 좌변의 상위클래스의
 * 참조자료형 변수는 오직 부모클래스의 객체공간의 주소값만을 갖고 있다. 자식클래스의 객체공간과 부모클래스의 객체공간이 같이 존재한다할지라도
 * 부모클래스의 객체공간만 가리키고 있는 주소값만을 갖고있는 것이다.
 * 이때, 생성된 객체공간에 부모클래스의 객체공간에 있는 메소드가 자식클래스의 객체공간에 오버라이딩된 경우에, 좌변의 부모클래스의 객체공간의 주소값을
 * 갖고 있는 참조자료형 변수를 통해 오버라이딩된 메소드를 접근했을때엔, 주소값이 부모클래스의 객체공간을 가리키고 있을지라도, 묵시적형변환의경우
 * 자식클래스의 오버라이딩된 메소드를 호출하게된다.
 * 
 * 즉, 묵시적형변환이 발생된경우 오버라이딩된 메소드의 우선순위는 자식클래스에 존재하는 메소드가 우선순위를 갖고 실행된다는 것이다. 부모클래스의
 * 메소드가 아니라!!
 * 
 * 자식클래스가 부모클래스를 상속받았을때, 실제로 자식클래스의 객체인스턴스의 범위는 부모의 객체공간과 자식의 객체공간을 합한 전체의 객체공간을의미한다.
 * 
 * 이러한 관계를 추상클래스가 자식클래스에 상속되는 과정이 아닌 모든 부모클래스와 자식클래스사이의 관계에서 항상성립되는 묵시적형변환이라는 원칙이다.
 * 
 * 메소드에 일반적으로 return 타입과 매개변수의 타입이 묵시적형변환으로 사용된다.
 * ## 시험문제!!
 * 
 * .점이 객체에접근한다고 했을때 객체.메소드() 와같이 생각할 수 있지만 본질적으로는 객체명.메소드() 와같이 점. 앞에는 본질적으로 객체명이 오고
 * 그 객체명은 본질적으로 주소값을 표현하고 있으므로, 그 주소값이 표현하는 객체인스턴스 공간을 가리키고 있고, 그 객체인스턴스 공간에 존재하는
 * 모든 것 즉, 변수, 메소드에 접근하는 것을 의미하는 것이다. 객체명에는 this, super, 참조변수명(주소값을 갖고잇음) 과 같은것이 올 수 있다.
 * 
 * 명시적형변환은 상위 클래스의 타입을 하위클래스가 가리키고 있는 것이다.
 * 
 * 명시적형변환은 묵시적형변환이 되어있는 부모의 참조변수만 자식변수가 가리킬수있다.
 * 
 * LgTV라는 참조변수가 가리키는 공간은 LgTV 는 자식클래스이므로, 부모인스턴스 객체의 공간과 자식인스턴스객체를 합한 공간을 가리켜야한다.
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */

public abstract class Printer {

	private String model;
	
	public Printer() {
		
	}
	public Printer(String model) {
		this.model = model;
	}
	
	public abstract void print();
}

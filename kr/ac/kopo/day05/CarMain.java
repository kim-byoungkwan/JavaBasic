package kr.ac.kopo.day05;

// 일반적으로 멤버변수는 직접 접근하는 것이 아니고, 메소드를 이용해서 접근한다.
// 인터페이스까지 배워야 객체지향스럽게 코드를 짤 수 있다.

public class CarMain {
	
	public static void main(String[] args) {
		
		Car c = new Car();
		c.name = "소나타";
		c.company = "현대";
		// 문자열은 new 키워드 없이 데이터를 생성할 수 있다.
		// 만약 name,company가 int 형 기본자료형이면 name,company 변수 자체가 "소나타", "현대" 라는데이터를
		// 직접 갖고 있을 텐데, 문자열 데이터는 문자열 참조자료형이므로, name,company 변수는 주소값을 갖고 있고,
		// 그 주소값이 실제 데이터를 가리키고 있다.
		
		// 클래스명은 대문자로 써야한다.
		// 위와 같이 Car라는 클래스를 new 키워드를 이용해서 힙 메모리에 인스턴스객체화시킬 수 있다.
		// 즉 위의 과정은 눈에보이는 자동차를 Car라는 클래스로 추상화 시켜서 이 Car 클래스를 new 키워드를 이용해
		// 힙 메모리에 인스턴스 객체화 시키는 과정인 것이다.
		// 이때 main 메소드를 가진 CarMain 클래스를 실행클래스라고한다.
		
		Car c2 = new Car();
		c2.name = "K9";
		c2.company = "기아";
		
		// c참조변수와 c2참조변수는 모두 같은 Car 라는 클래스를 통해 만든 참조변수이므로, 동일한 멤버변수와 메소드를
		// 갖고 있다. 
		// () 이러한 괄호는 생정자라고 한다. 만약 new Car 와 같이 생성자 () 없이 표현하면, 문법적으로 성립하지 않는다.
		// 즉 설계도인 클래스를 이용해 힙 메모리에 저장공간을 생성하여 인스턴스 객체를 생성하기 위해선 new 라는 키워드와
		// 클래스의 이름 그리고 () 괄호라는 생성자가 모두 있어야만 가능하다.
		
		System.out.println("첫번째 자동차명 : " + c.name);
		
		System.out.println("두번째 자동차명 : " + c2.name);
		
		// . 점의 의미는 어떠한 클래스를 통해 생성된 인스턴스 객체가 갖고 있는 멤버변수와 메소드에 접근하고자 할때 사용한다.
		// . 점의 의미는 위의 의미 외엔 없다.
		
	}

}
